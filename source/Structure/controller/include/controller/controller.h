/*
 * This file is part of the ProVANT simulator project.
 * Licensed under the terms of the MIT open source license. More details at
 * https://github.com/Guiraffo/ProVANT-Simulator/blob/master/LICENSE.md
 */
/**
 * \file This file contains the declaration of the Controller2 class.
 *
 * @author Arthur Viana Lara
 * @author JÃºnio Eduardo de Morais Aquino
 */

#ifndef CONTROLLER_H
#define CONTROLLER_H

#include <list>
#include <map>
#include <mutex>
#include <string>
#include <vector>
#include "ros/ros.h"
#include "std_msgs/Float64.h"
#include "std_msgs/String.h"
#include "controller/MatlabData.h"
#include "controller/XMLRead.h"
#include "simulator_msgs/Sensor.h"
#include "simulator_msgs/SensorArray.h"
#include "Icontroller.hpp"

class ControllerNode
{
public:
  /**
   * @brief Initializes ROS.
   * 
   * @param argc Number of arguments received by the program.
   * @param argv List of arugments recevied by the program.
   */
	static void init(int argc, char** argv);

  /**
   * @brief Construct a new Controller Node object.
   */
	ControllerNode();

  /**
   * @brief Destroy the Controller Node object and release the handles to the
   * DLLs.
   */
	virtual ~ControllerNode();

  /**
   * @brief Start the simulation.
   * 
   * This method emits the first step message, and thus allows the start of the
   * simulation.
   */
  void startSimulation();

private:
  /**
   * @brief XML file containing the configuration of this simulation.
   * 
   * This object is used to read the value of the XML tags containing the
   * desired parameters for the simulation, such as the control law execution
   * ratio, path to the log files, and the desired control strategy.
   */
	XMLRead configFile;

  /**
   * @brief Handle for the ROS node.
   */
	ros::NodeHandle nh;

  /**
   * @brief Store the ROS publishers for the topics of the actuators.
   * 
   * @todo Convert this to a std::list after the refactoring of the XMLRead
   * class.
   */
  std::vector<ros::Publisher> actuatorPublishersArray;

  /**
   * @brief Stores the list of ROS subscribers to the topics of the sensors.
   * 
   * OBS: Storing the references to the subscribers is necessary because ROS
   * remvoes the subscription as soon as a subscriber object goes out of scope.
   * 
   * @todo Convert this to a std::list after the refactoring of the XMLRead
   * class.
   */
	std::vector<ros::Subscriber> sensorSubscribers;

  /**
   * @brief This value determines how many steps must pass before a new 
   * execution of the control law.
   * 
   * For example, for a controlLawExecutionRatio with value 10, the control law
   * will only be executed once at every 10 steps.
   * 
   * For a controlLawExecutionRatio with value 12, the control law will only
   * be executed once at every 12 steps, and os for. 
   */
	int controlLawExecutionRatio;

  /**
   * @brief Counter that stores the number of steps during each execution cyle.
   * 
   * This counter is used to determine when the control law must be executed
   * in order ot update the control input values.
   */
  int stepCounter;

  /**
   * @brief Name of the control strategy library executed in this node.
   */
  std::string controlStrategy;

  /**
   * @brief Map from the name of a sensor to the index in the sensor array
   * passed to the control law.
   * 
   * This variable is necessary to ensure that the order of the sensors
   * is always the same in the message sent to the control law execute 
   * method.
   */
  std::map<std::string, int> sensorIndexMap;

  /**
   * @brief Counter that stores the number of updated states during each step
   * time.
   */
  int sensorCounter;

  /**
   * @brief File to log the control inputs generated by the control law.
   */
  MatlabData controlInputsLog;

  /**
   * @brief File to log the value of the model states.
   */
	MatlabData stateLog;

  /**
   * @brief File to log the reference values.
   */
	MatlabData referenceLog;

  /**
   * @brief File to log the tracking error values.
   */
	MatlabData trackingErrorLog;

  /**
   * @brief Mutex used by the states update callback.
   */
  std::mutex _mutex;

  /**
   * @brief Stores the last values of the control inputs generated by the
   * control law.
   */
  std::vector<double> controlInputs;

  /**
   * @brief Stores the data of the sensors received from the Gazebo simulator
   * during the last sampling period.
   */
  simulator_msgs::SensorArray sensorData;

	/**
	 * @brief ROS topic to advance one simulation step in gazebo.
	 */
	ros::Publisher stepPublisher;
	
  /**
   * @brief Handle to the instance of the dynamicly loaded library that contains
   * the instance of the control strategy.
   */
  void* dllHandle = NULL;
  
  /**
   * @brief Instance of the control strategy executed by this node.
   */
  Icontroller* controller = NULL;

	/**
	 * @brief Advance one step in the simulation.
	 * 
	 * This method publishes a message in the step topic, that has the function
	 * to inform gazebo that the simulation must be advanced in one step, with
	 * duration equal to the configured sample time.
	 */
	void step();

  /**
   * @brief Creates and initializes an instance of the control strategy dynamic
   * library.
   * 
   * This method constructs an instance of the control strategy DLL, and the 
   * create function contained in the DLL, stores their handles, and 
   * initializes an instance of the control strategy control loop.
   * 
   * If an error is encountered at any step, an appropriate log message is
   * sent and an the execution of the node is halted with a failure status.
   */
	void setupControlStrategy();

  /**
   * @brief Create and verify the dat files for the simulation log.
   * 
   * This method create the files for the logs of the references, states,
   * tracking error and applied control inputs generated during the simulation.
   * 
   * The methods also verify that all of the files were successfully open and
   * emits appropriate log messages and halts the node execution with a failure
   * status otherwise.
   */
  void setupLogging();

  /**
   * @brief Callback method called when a sensor message is received by the 
   * node.
   * 
   * This function checks if a sensor with a valid name was configured in the
   * sensor list of the config.xml file, and inserts it under the appropriate
   * index of a SensorArray message that is passes to the control strategy.
   * 
   * If a sensor with a unrecognized name is recevied, an appropriate log 
   * message is emitted.
   * 
   * @param msg 
   */
  void stateUpdateCallback(simulator_msgs::Sensor msg);

  /**
   * @brief Method that executes the control law and apply the resulting control
   * inputs to the actuators.
   * 
   * To enhance the value read from the sensors during the simulation, the
   * control law is only executed once at each execution cycle.
   * 
   * The execution cycle is a positive integer value set by the
   * controlLawExecutionRatio member variable, for more details about this see
   * the documentation of this variable.
   * 
   * After executing the control law, the control inputs are updated and sent
   * to configured topic for each actuator.
   */
  void controlLaw();

  /**
   * @brief Configures the ROS node, subscribe to the nodes to receive updates
   * from the sensor and the publishers to update the control input values.
   * 
   * This method performs the initialization fo the ROS node and reads the
   * parameters from the config.xml file indiating what the selected control
   * strategy is, and what is the value for the controlLawExecutionRatio.
   */
  void setupNode();
};

#endif // CONTROLLER_H
